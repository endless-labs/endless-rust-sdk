// Copyright © Endless
// Copyright © Aptos Foundation
// SPDX-License-Identifier: Apache-2.0

// This file was generated. Do not modify!
//
// To update this code, run: `cargo run --release -p framework`.

// Conversion library between a structured representation of a Move script call (`ScriptCall`) and the
// standard BCS-compatible representation used in Endless transactions (`Script`).
//
// This code was generated by compiling known Script interfaces ("ABIs") with the tool `endless-sdk-builder`.

#![allow(dead_code)]
#![allow(unused_imports)]
#![allow(clippy::too_many_arguments)]
#![allow(clippy::arc_with_non_send_sync)]
#![allow(clippy::get_first)]
use endless_types::{
    account_address::AccountAddress,
    transaction::{EntryFunction, TransactionPayload},
};
use move_core_types::{
    ident_str,
    language_storage::{ModuleId, TypeTag},
};

type Bytes = Vec<u8>;

/// Structured representation of a call into a known Move entry function.
/// ```ignore
/// impl EntryFunctionCall {
///     pub fn encode(self) -> TransactionPayload { .. }
///     pub fn decode(&TransactionPayload) -> Option<EntryFunctionCall> { .. }
/// }
/// ```
#[derive(Clone, Debug, PartialEq, Eq)]
#[cfg_attr(feature = "fuzzing", derive(proptest_derive::Arbitrary))]
#[cfg_attr(feature = "fuzzing", proptest(no_params))]
pub enum EntryFunctionCall {
    /// Burn fungible assets as the owner of metadata object.
    CoinBurn { asset: AccountAddress, amount: u128 },

    /// Create metadata object and store the refs.
    CoinCreate {
        max_supply: u128,
        name: Vec<u8>,
        symbol: Vec<u8>,
        decimals: u8,
        icon_uri: Vec<u8>,
        project_uri: Vec<u8>,
    },

    /// Create metadata object and store the refs.
    CoinCreateEx {
        max_supply: u128,
        name: Vec<u8>,
        symbol: Vec<u8>,
        decimals: u8,
        icon_uri: Vec<u8>,
        project_uri: Vec<u8>,
    },

    /// Only called burn capability once all initial validators
    CoinDestroyBurnCap { asset: AccountAddress },

    /// Only called mint capability once all initial validators
    CoinDestroyMintCap { asset: AccountAddress },

    /// Only called transfer capability once all initial validators
    CoinDestroyTransferCap { asset: AccountAddress },

    /// Freeze an account so it cannot transfer or receive fungible assets.
    CoinFreezeAccount {
        asset: AccountAddress,
        account: AccountAddress,
    },

    /// Mint as the owner of metadata object and deposit to a specific account.
    CoinMint {
        asset: AccountAddress,
        to: AccountAddress,
        amount: u128,
    },

    CoinSetIconUri {
        asset: AccountAddress,
        icon_uri: Vec<u8>,
    },

    CoinSetProjectUri {
        asset: AccountAddress,
        project_uri: Vec<u8>,
    },

    /// Transfer as the owner of metadata object ignoring `frozen` field.
    CoinTransfer {
        asset: AccountAddress,
        to: AccountAddress,
        amount: u128,
    },

    /// Unfreeze an account so it can transfer or receive fungible assets.
    CoinUnfreezeAccount {
        asset: AccountAddress,
        account: AccountAddress,
    },

    /// Create a new collection
    NftCreateCollection {
        description: Vec<u8>,
        max_supply: u64,
        name: Vec<u8>,
        uri: Vec<u8>,
        mutable_description: bool,
        mutable_royalty: bool,
        mutable_uri: bool,
        mutable_token_description: bool,
        mutable_token_name: bool,
        mutable_token_properties: bool,
        mutable_token_uri: bool,
        tokens_burnable_by_creator: bool,
        tokens_freezable_by_creator: bool,
        royalty_numerator: u64,
        royalty_denominator: u64,
    },

    /// With an existing collection, directly mint a viable token into the creators account.
    NftMint {
        collection: Vec<u8>,
        description: Vec<u8>,
        name: Vec<u8>,
        uri: Vec<u8>,
        property_keys: Vec<Vec<u8>>,
        property_types: Vec<Vec<u8>>,
        property_values: Vec<Vec<u8>>,
    },

    /// With an existing collection, directly mint a soul bound token into the recipient's account.
    NftMintSoulBound {
        collection: Vec<u8>,
        description: Vec<u8>,
        name: Vec<u8>,
        uri: Vec<u8>,
        property_keys: Vec<Vec<u8>>,
        property_types: Vec<Vec<u8>>,
        property_values: Vec<Vec<u8>>,
        soul_bound_to: AccountAddress,
    },
}

impl EntryFunctionCall {
    /// Build an Endless `TransactionPayload` from a structured object `EntryFunctionCall`.
    pub fn encode(self) -> TransactionPayload {
        use EntryFunctionCall::*;
        match self {
            CoinBurn { asset, amount } => coin_burn(asset, amount),
            CoinCreate {
                max_supply,
                name,
                symbol,
                decimals,
                icon_uri,
                project_uri,
            } => coin_create(max_supply, name, symbol, decimals, icon_uri, project_uri),
            CoinCreateEx {
                max_supply,
                name,
                symbol,
                decimals,
                icon_uri,
                project_uri,
            } => coin_create_ex(max_supply, name, symbol, decimals, icon_uri, project_uri),
            CoinDestroyBurnCap { asset } => coin_destroy_burn_cap(asset),
            CoinDestroyMintCap { asset } => coin_destroy_mint_cap(asset),
            CoinDestroyTransferCap { asset } => coin_destroy_transfer_cap(asset),
            CoinFreezeAccount { asset, account } => coin_freeze_account(asset, account),
            CoinMint { asset, to, amount } => coin_mint(asset, to, amount),
            CoinSetIconUri { asset, icon_uri } => coin_set_icon_uri(asset, icon_uri),
            CoinSetProjectUri { asset, project_uri } => coin_set_project_uri(asset, project_uri),
            CoinTransfer { asset, to, amount } => coin_transfer(asset, to, amount),
            CoinUnfreezeAccount { asset, account } => coin_unfreeze_account(asset, account),
            NftCreateCollection {
                description,
                max_supply,
                name,
                uri,
                mutable_description,
                mutable_royalty,
                mutable_uri,
                mutable_token_description,
                mutable_token_name,
                mutable_token_properties,
                mutable_token_uri,
                tokens_burnable_by_creator,
                tokens_freezable_by_creator,
                royalty_numerator,
                royalty_denominator,
            } => nft_create_collection(
                description,
                max_supply,
                name,
                uri,
                mutable_description,
                mutable_royalty,
                mutable_uri,
                mutable_token_description,
                mutable_token_name,
                mutable_token_properties,
                mutable_token_uri,
                tokens_burnable_by_creator,
                tokens_freezable_by_creator,
                royalty_numerator,
                royalty_denominator,
            ),
            NftMint {
                collection,
                description,
                name,
                uri,
                property_keys,
                property_types,
                property_values,
            } => nft_mint(
                collection,
                description,
                name,
                uri,
                property_keys,
                property_types,
                property_values,
            ),
            NftMintSoulBound {
                collection,
                description,
                name,
                uri,
                property_keys,
                property_types,
                property_values,
                soul_bound_to,
            } => nft_mint_soul_bound(
                collection,
                description,
                name,
                uri,
                property_keys,
                property_types,
                property_values,
                soul_bound_to,
            ),
        }
    }

    /// Try to recognize an Endless `TransactionPayload` and convert it into a structured object `EntryFunctionCall`.
    pub fn decode(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            match SCRIPT_FUNCTION_DECODER_MAP.get(&format!(
                "{}_{}",
                script.module().name(),
                script.function()
            )) {
                Some(decoder) => decoder(payload),
                None => None,
            }
        } else {
            None
        }
    }
}

/// Burn fungible assets as the owner of metadata object.
pub fn coin_burn(asset: AccountAddress, amount: u128) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 4,
            ]),
            ident_str!("coin").to_owned(),
        ),
        ident_str!("burn").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&asset).unwrap(),
            bcs::to_bytes(&amount).unwrap(),
        ],
    ))
}

/// Create metadata object and store the refs.
pub fn coin_create(
    max_supply: u128,
    name: Vec<u8>,
    symbol: Vec<u8>,
    decimals: u8,
    icon_uri: Vec<u8>,
    project_uri: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 4,
            ]),
            ident_str!("coin").to_owned(),
        ),
        ident_str!("create").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&max_supply).unwrap(),
            bcs::to_bytes(&name).unwrap(),
            bcs::to_bytes(&symbol).unwrap(),
            bcs::to_bytes(&decimals).unwrap(),
            bcs::to_bytes(&icon_uri).unwrap(),
            bcs::to_bytes(&project_uri).unwrap(),
        ],
    ))
}

/// Create metadata object and store the refs.
pub fn coin_create_ex(
    max_supply: u128,
    name: Vec<u8>,
    symbol: Vec<u8>,
    decimals: u8,
    icon_uri: Vec<u8>,
    project_uri: Vec<u8>,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 4,
            ]),
            ident_str!("coin").to_owned(),
        ),
        ident_str!("create_ex").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&max_supply).unwrap(),
            bcs::to_bytes(&name).unwrap(),
            bcs::to_bytes(&symbol).unwrap(),
            bcs::to_bytes(&decimals).unwrap(),
            bcs::to_bytes(&icon_uri).unwrap(),
            bcs::to_bytes(&project_uri).unwrap(),
        ],
    ))
}

/// Only called burn capability once all initial validators
pub fn coin_destroy_burn_cap(asset: AccountAddress) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 4,
            ]),
            ident_str!("coin").to_owned(),
        ),
        ident_str!("destroy_burn_cap").to_owned(),
        vec![],
        vec![bcs::to_bytes(&asset).unwrap()],
    ))
}

/// Only called mint capability once all initial validators
pub fn coin_destroy_mint_cap(asset: AccountAddress) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 4,
            ]),
            ident_str!("coin").to_owned(),
        ),
        ident_str!("destroy_mint_cap").to_owned(),
        vec![],
        vec![bcs::to_bytes(&asset).unwrap()],
    ))
}

/// Only called transfer capability once all initial validators
pub fn coin_destroy_transfer_cap(asset: AccountAddress) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 4,
            ]),
            ident_str!("coin").to_owned(),
        ),
        ident_str!("destroy_transfer_cap").to_owned(),
        vec![],
        vec![bcs::to_bytes(&asset).unwrap()],
    ))
}

/// Freeze an account so it cannot transfer or receive fungible assets.
pub fn coin_freeze_account(asset: AccountAddress, account: AccountAddress) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 4,
            ]),
            ident_str!("coin").to_owned(),
        ),
        ident_str!("freeze_account").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&asset).unwrap(),
            bcs::to_bytes(&account).unwrap(),
        ],
    ))
}

/// Mint as the owner of metadata object and deposit to a specific account.
pub fn coin_mint(asset: AccountAddress, to: AccountAddress, amount: u128) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 4,
            ]),
            ident_str!("coin").to_owned(),
        ),
        ident_str!("mint").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&asset).unwrap(),
            bcs::to_bytes(&to).unwrap(),
            bcs::to_bytes(&amount).unwrap(),
        ],
    ))
}

pub fn coin_set_icon_uri(asset: AccountAddress, icon_uri: Vec<u8>) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 4,
            ]),
            ident_str!("coin").to_owned(),
        ),
        ident_str!("set_icon_uri").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&asset).unwrap(),
            bcs::to_bytes(&icon_uri).unwrap(),
        ],
    ))
}

pub fn coin_set_project_uri(asset: AccountAddress, project_uri: Vec<u8>) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 4,
            ]),
            ident_str!("coin").to_owned(),
        ),
        ident_str!("set_project_uri").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&asset).unwrap(),
            bcs::to_bytes(&project_uri).unwrap(),
        ],
    ))
}

/// Transfer as the owner of metadata object ignoring `frozen` field.
pub fn coin_transfer(
    asset: AccountAddress,
    to: AccountAddress,
    amount: u128,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 4,
            ]),
            ident_str!("coin").to_owned(),
        ),
        ident_str!("transfer").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&asset).unwrap(),
            bcs::to_bytes(&to).unwrap(),
            bcs::to_bytes(&amount).unwrap(),
        ],
    ))
}

/// Unfreeze an account so it can transfer or receive fungible assets.
pub fn coin_unfreeze_account(asset: AccountAddress, account: AccountAddress) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 4,
            ]),
            ident_str!("coin").to_owned(),
        ),
        ident_str!("unfreeze_account").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&asset).unwrap(),
            bcs::to_bytes(&account).unwrap(),
        ],
    ))
}

/// Create a new collection
pub fn nft_create_collection(
    description: Vec<u8>,
    max_supply: u64,
    name: Vec<u8>,
    uri: Vec<u8>,
    mutable_description: bool,
    mutable_royalty: bool,
    mutable_uri: bool,
    mutable_token_description: bool,
    mutable_token_name: bool,
    mutable_token_properties: bool,
    mutable_token_uri: bool,
    tokens_burnable_by_creator: bool,
    tokens_freezable_by_creator: bool,
    royalty_numerator: u64,
    royalty_denominator: u64,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 4,
            ]),
            ident_str!("nft").to_owned(),
        ),
        ident_str!("create_collection").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&description).unwrap(),
            bcs::to_bytes(&max_supply).unwrap(),
            bcs::to_bytes(&name).unwrap(),
            bcs::to_bytes(&uri).unwrap(),
            bcs::to_bytes(&mutable_description).unwrap(),
            bcs::to_bytes(&mutable_royalty).unwrap(),
            bcs::to_bytes(&mutable_uri).unwrap(),
            bcs::to_bytes(&mutable_token_description).unwrap(),
            bcs::to_bytes(&mutable_token_name).unwrap(),
            bcs::to_bytes(&mutable_token_properties).unwrap(),
            bcs::to_bytes(&mutable_token_uri).unwrap(),
            bcs::to_bytes(&tokens_burnable_by_creator).unwrap(),
            bcs::to_bytes(&tokens_freezable_by_creator).unwrap(),
            bcs::to_bytes(&royalty_numerator).unwrap(),
            bcs::to_bytes(&royalty_denominator).unwrap(),
        ],
    ))
}

/// With an existing collection, directly mint a viable token into the creators account.
pub fn nft_mint(
    collection: Vec<u8>,
    description: Vec<u8>,
    name: Vec<u8>,
    uri: Vec<u8>,
    property_keys: Vec<Vec<u8>>,
    property_types: Vec<Vec<u8>>,
    property_values: Vec<Vec<u8>>,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 4,
            ]),
            ident_str!("nft").to_owned(),
        ),
        ident_str!("mint").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&collection).unwrap(),
            bcs::to_bytes(&description).unwrap(),
            bcs::to_bytes(&name).unwrap(),
            bcs::to_bytes(&uri).unwrap(),
            bcs::to_bytes(&property_keys).unwrap(),
            bcs::to_bytes(&property_types).unwrap(),
            bcs::to_bytes(&property_values).unwrap(),
        ],
    ))
}

/// With an existing collection, directly mint a soul bound token into the recipient's account.
pub fn nft_mint_soul_bound(
    collection: Vec<u8>,
    description: Vec<u8>,
    name: Vec<u8>,
    uri: Vec<u8>,
    property_keys: Vec<Vec<u8>>,
    property_types: Vec<Vec<u8>>,
    property_values: Vec<Vec<u8>>,
    soul_bound_to: AccountAddress,
) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 4,
            ]),
            ident_str!("nft").to_owned(),
        ),
        ident_str!("mint_soul_bound").to_owned(),
        vec![],
        vec![
            bcs::to_bytes(&collection).unwrap(),
            bcs::to_bytes(&description).unwrap(),
            bcs::to_bytes(&name).unwrap(),
            bcs::to_bytes(&uri).unwrap(),
            bcs::to_bytes(&property_keys).unwrap(),
            bcs::to_bytes(&property_types).unwrap(),
            bcs::to_bytes(&property_values).unwrap(),
            bcs::to_bytes(&soul_bound_to).unwrap(),
        ],
    ))
}
mod decoder {
    use super::*;
    pub fn coin_burn(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::CoinBurn {
                asset: bcs::from_bytes(script.args().get(0)?).ok()?,
                amount: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn coin_create(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::CoinCreate {
                max_supply: bcs::from_bytes(script.args().get(0)?).ok()?,
                name: bcs::from_bytes(script.args().get(1)?).ok()?,
                symbol: bcs::from_bytes(script.args().get(2)?).ok()?,
                decimals: bcs::from_bytes(script.args().get(3)?).ok()?,
                icon_uri: bcs::from_bytes(script.args().get(4)?).ok()?,
                project_uri: bcs::from_bytes(script.args().get(5)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn coin_create_ex(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::CoinCreateEx {
                max_supply: bcs::from_bytes(script.args().get(0)?).ok()?,
                name: bcs::from_bytes(script.args().get(1)?).ok()?,
                symbol: bcs::from_bytes(script.args().get(2)?).ok()?,
                decimals: bcs::from_bytes(script.args().get(3)?).ok()?,
                icon_uri: bcs::from_bytes(script.args().get(4)?).ok()?,
                project_uri: bcs::from_bytes(script.args().get(5)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn coin_destroy_burn_cap(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::CoinDestroyBurnCap {
                asset: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn coin_destroy_mint_cap(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::CoinDestroyMintCap {
                asset: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn coin_destroy_transfer_cap(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::CoinDestroyTransferCap {
                asset: bcs::from_bytes(script.args().get(0)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn coin_freeze_account(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::CoinFreezeAccount {
                asset: bcs::from_bytes(script.args().get(0)?).ok()?,
                account: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn coin_mint(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::CoinMint {
                asset: bcs::from_bytes(script.args().get(0)?).ok()?,
                to: bcs::from_bytes(script.args().get(1)?).ok()?,
                amount: bcs::from_bytes(script.args().get(2)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn coin_set_icon_uri(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::CoinSetIconUri {
                asset: bcs::from_bytes(script.args().get(0)?).ok()?,
                icon_uri: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn coin_set_project_uri(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::CoinSetProjectUri {
                asset: bcs::from_bytes(script.args().get(0)?).ok()?,
                project_uri: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn coin_transfer(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::CoinTransfer {
                asset: bcs::from_bytes(script.args().get(0)?).ok()?,
                to: bcs::from_bytes(script.args().get(1)?).ok()?,
                amount: bcs::from_bytes(script.args().get(2)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn coin_unfreeze_account(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::CoinUnfreezeAccount {
                asset: bcs::from_bytes(script.args().get(0)?).ok()?,
                account: bcs::from_bytes(script.args().get(1)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn nft_create_collection(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::NftCreateCollection {
                description: bcs::from_bytes(script.args().get(0)?).ok()?,
                max_supply: bcs::from_bytes(script.args().get(1)?).ok()?,
                name: bcs::from_bytes(script.args().get(2)?).ok()?,
                uri: bcs::from_bytes(script.args().get(3)?).ok()?,
                mutable_description: bcs::from_bytes(script.args().get(4)?).ok()?,
                mutable_royalty: bcs::from_bytes(script.args().get(5)?).ok()?,
                mutable_uri: bcs::from_bytes(script.args().get(6)?).ok()?,
                mutable_token_description: bcs::from_bytes(script.args().get(7)?).ok()?,
                mutable_token_name: bcs::from_bytes(script.args().get(8)?).ok()?,
                mutable_token_properties: bcs::from_bytes(script.args().get(9)?).ok()?,
                mutable_token_uri: bcs::from_bytes(script.args().get(10)?).ok()?,
                tokens_burnable_by_creator: bcs::from_bytes(script.args().get(11)?).ok()?,
                tokens_freezable_by_creator: bcs::from_bytes(script.args().get(12)?).ok()?,
                royalty_numerator: bcs::from_bytes(script.args().get(13)?).ok()?,
                royalty_denominator: bcs::from_bytes(script.args().get(14)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn nft_mint(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::NftMint {
                collection: bcs::from_bytes(script.args().get(0)?).ok()?,
                description: bcs::from_bytes(script.args().get(1)?).ok()?,
                name: bcs::from_bytes(script.args().get(2)?).ok()?,
                uri: bcs::from_bytes(script.args().get(3)?).ok()?,
                property_keys: bcs::from_bytes(script.args().get(4)?).ok()?,
                property_types: bcs::from_bytes(script.args().get(5)?).ok()?,
                property_values: bcs::from_bytes(script.args().get(6)?).ok()?,
            })
        } else {
            None
        }
    }

    pub fn nft_mint_soul_bound(payload: &TransactionPayload) -> Option<EntryFunctionCall> {
        if let TransactionPayload::EntryFunction(script) = payload {
            Some(EntryFunctionCall::NftMintSoulBound {
                collection: bcs::from_bytes(script.args().get(0)?).ok()?,
                description: bcs::from_bytes(script.args().get(1)?).ok()?,
                name: bcs::from_bytes(script.args().get(2)?).ok()?,
                uri: bcs::from_bytes(script.args().get(3)?).ok()?,
                property_keys: bcs::from_bytes(script.args().get(4)?).ok()?,
                property_types: bcs::from_bytes(script.args().get(5)?).ok()?,
                property_values: bcs::from_bytes(script.args().get(6)?).ok()?,
                soul_bound_to: bcs::from_bytes(script.args().get(7)?).ok()?,
            })
        } else {
            None
        }
    }
}

type EntryFunctionDecoderMap = std::collections::HashMap<
    String,
    Box<
        dyn Fn(&TransactionPayload) -> Option<EntryFunctionCall>
            + std::marker::Sync
            + std::marker::Send,
    >,
>;

static SCRIPT_FUNCTION_DECODER_MAP: once_cell::sync::Lazy<EntryFunctionDecoderMap> =
    once_cell::sync::Lazy::new(|| {
        let mut map: EntryFunctionDecoderMap = std::collections::HashMap::new();
        map.insert("coin_burn".to_string(), Box::new(decoder::coin_burn));
        map.insert("coin_create".to_string(), Box::new(decoder::coin_create));
        map.insert(
            "coin_create_ex".to_string(),
            Box::new(decoder::coin_create_ex),
        );
        map.insert(
            "coin_destroy_burn_cap".to_string(),
            Box::new(decoder::coin_destroy_burn_cap),
        );
        map.insert(
            "coin_destroy_mint_cap".to_string(),
            Box::new(decoder::coin_destroy_mint_cap),
        );
        map.insert(
            "coin_destroy_transfer_cap".to_string(),
            Box::new(decoder::coin_destroy_transfer_cap),
        );
        map.insert(
            "coin_freeze_account".to_string(),
            Box::new(decoder::coin_freeze_account),
        );
        map.insert("coin_mint".to_string(), Box::new(decoder::coin_mint));
        map.insert(
            "coin_set_icon_uri".to_string(),
            Box::new(decoder::coin_set_icon_uri),
        );
        map.insert(
            "coin_set_project_uri".to_string(),
            Box::new(decoder::coin_set_project_uri),
        );
        map.insert(
            "coin_transfer".to_string(),
            Box::new(decoder::coin_transfer),
        );
        map.insert(
            "coin_unfreeze_account".to_string(),
            Box::new(decoder::coin_unfreeze_account),
        );
        map.insert(
            "nft_create_collection".to_string(),
            Box::new(decoder::nft_create_collection),
        );
        map.insert("nft_mint".to_string(), Box::new(decoder::nft_mint));
        map.insert(
            "nft_mint_soul_bound".to_string(),
            Box::new(decoder::nft_mint_soul_bound),
        );
        map
    });
